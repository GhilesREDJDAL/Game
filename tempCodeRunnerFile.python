import pygame
import sys

# Initialisation de Pygame
pygame.init()

# Dimensions de l'écran
SCREEN_WIDTH = 800
SCREEN_HEIGHT = 600
GRID_SIZE = 40

# Couleurs
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
GRAY = (100, 100, 100)
RED = (255, 0, 0)
BLUE = (0, 0, 255)
GREEN = (0, 255, 0)
YELLOW = (255, 255, 0)

# Création de l'écran
screen = pygame.display.set_mode((SCREEN_WIDTH, SCREEN_HEIGHT))
pygame.display.set_caption("Jeu de stratégie 2D")

# Classe pour les cases du terrain
class Tile:
    def __init__(self, x, y, traversable=True, color=WHITE):
        self.x = x
        self.y = y
        self.traversable = traversable
        self.color = color

    def draw(self, surface):
        pygame.draw.rect(
            surface, 
            self.color, 
            (self.x * GRID_SIZE, self.y * GRID_SIZE, GRID_SIZE, GRID_SIZE)
        )

# Classe pour les compétences
class Skill:
    def __init__(self, name, power, range, aoe, cooldown, effect_type="damage"):
        self.name = name
        self.power = power
        self.range = range
        self.aoe = aoe
        self.cooldown = cooldown
        self.effect_type = effect_type
        self.current_cooldown = 0

    def is_available(self):
        return self.current_cooldown == 0

    def use(self):
        if self.is_available():
            self.current_cooldown = self.cooldown

    def reduce_cooldown(self):
        if self.current_cooldown > 0:
            self.current_cooldown -= 1

# Classe pour les unités
class Unit:
    def __init__(self, x, y, health, attack, defense, speed, color=BLUE):
        self.x = x
        self.y = y
        self.health = health
        self.attack = attack
        self.defense = defense
        self.speed = speed
        self.color = color
        self.skills = []

    def move(self, dx, dy, grid):
        new_x = self.x + dx
        new_y = self.y + dy
        if 0 <= new_x < len(grid[0]) and 0 <= new_y < len(grid):
            if grid[new_y][new_x].traversable:
                self.x = new_x
                self.y = new_y

    def draw(self, surface):
        pygame.draw.circle(
            surface,
            self.color,
            (self.x * GRID_SIZE + GRID_SIZE // 2, self.y * GRID_SIZE + GRID_SIZE // 2),
            GRID_SIZE // 3,
        )

    def add_skill(self, skill):
        self.skills.append(skill)

    def use_skill(self, skill_index, target, grid):
        if skill_index < 0 or skill_index >= len(self.skills):
            print("Compétence invalide.")
            return

        skill = self.skills[skill_index]
        if not skill.is_available():
            print(f"{skill.name} est en recharge.")
            return

        distance = abs(self.x - target.x) + abs(self.y - target.y)
        if distance > skill.range:
            print(f"{target} est hors de portée pour {skill.name}.")
            return

        if skill.effect_type == "damage":
            damage = max(0, skill.power + self.attack - target.defense)
            target.health -= damage
            print(f"{self} inflige {damage} points de dégâts à {target} avec {skill.name}.")
        elif skill.effect_type == "heal":
            target.health = min(target.health + skill.power, 100)
            print(f"{self} soigne {target} avec {skill.name}.")

        skill.use()

# Classe pour le jeu
class Game:
    def __init__(self, grid):
        self.grid = grid
        self.players = []
        self.current_player = 0
        self.current_unit = 0

    def add_player(self, player_units):
        self.players.append(player_units)

    def next_turn(self):
        self.current_player = (self.current_player + 1) % len(self.players)
        self.current_unit = 0

    def next_unit(self):
        self.current_unit = (self.current_unit + 1) % len(self.players[self.current_player])

    def get_active_unit(self):
        return self.players[self.current_player][self.current_unit]

# Sélection de cible
selected_target = None

def select_target(grid, current_unit, players, dx=0, dy=0):
    global selected_target
    if not selected_target:
        selected_target = (current_unit.x, current_unit.y)
    x, y = selected_target
    x += dx
    y += dy
    if 0 <= x < len(grid[0]) and 0 <= y < len(grid):
        selected_target = (x, y)

def get_target_unit(x, y, players):
    for player_units in players:
        for unit in player_units:
            if unit.x == x and unit.y == y:
                return unit
    return None

def draw_target_selection(surface, x, y):
    pygame.draw.rect(
        surface,
        YELLOW,
        (x * GRID_SIZE, y * GRID_SIZE, GRID_SIZE, GRID_SIZE),
        3,
    )

def draw_skills(surface, unit):
    font = pygame.font.Font(None, 24)
    y_offset = 10
    for i, skill in enumerate(unit.skills):
        skill_text = f"{i + 1}. {skill.name} (CD: {skill.current_cooldown}/{skill.cooldown})"
        color = GREEN if skill.is_available() else GRAY
        text_surface = font.render(skill_text, True, color)
        surface.blit(text_surface, (10, y_offset))
        y_offset += 20

# Boucle principale
def main():
    clock = pygame.time.Clock()
    running = True
    grid = [[Tile(x, y) for x in range(SCREEN_WIDTH // GRID_SIZE)] for y in range(SCREEN_HEIGHT // GRID_SIZE)]
    game = Game(grid)

    # Ajouter des joueurs et unités
    player1_units = [Unit(2, 2, 100, 10, 5, 2, color=BLUE), Unit(3, 3, 120, 8, 6, 1, color=GREEN)]
    player2_units = [Unit(5, 5, 90, 12, 4, 2, color=RED), Unit(6, 6, 110, 9, 7, 1, color=YELLOW)]
    game.add_player(player1_units)
    game.add_player(player2_units)

    # Ajouter des compétences
    fireball = Skill("Fireball", power=30, range=3, aoe=0, cooldown=2)
    heal = Skill("Heal", power=20, range=2, aoe=0, cooldown=1, effect_type="heal")
    player1_units[0].add_skill(fireball)
    player1_units[1].add_skill(heal)
    player2_units[0].add_skill(fireball)
    player2_units[1].add_skill(heal)

    while running:
        screen.fill(BLACK)
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                running = False
            elif event.type == pygame.KEYDOWN:
                active_unit = game.get_active_unit()  # Définir active_unit ici

                # Déplacement de l'unité active
                if event.key == pygame.K_UP:
                    active_unit.move(0, -1, game.grid)
                elif event.key == pygame.K_DOWN:
                    active_unit.move(0, 1, game.grid)
                elif event.key == pygame.K_LEFT:
                    active_unit.move(-1, 0, game.grid)
                elif event.key == pygame.K_RIGHT:
                    active_unit.move(1, 0, game.grid)

                # Changer l'unité active
                elif event.key == pygame.K_RETURN:
                    game.next_unit()

                # Passer au prochain joueur
                elif event.key == pygame.K_SPACE:
                    game.next_turn()

                # Sélection de la cible et utilisation des compétences
                elif event.key in [pygame.K_1, pygame.K_2]:
                    skill_index = event.key - pygame.K_1
                    if selected_target:
                        target_unit = get_target_unit(*selected_target, game.players)
                        if target_unit:
                            active_unit.use_skill(skill_index, target_unit, game.grid)
                        else:
                            print("Aucune unité à cette position.")

        # Dessiner la grille
        for row in grid:
            for tile in row:
                tile.draw(screen)

        # Dessiner les unités
        for player_units in game.players:
            for unit in player_units:
                unit.draw(screen)

        # Dessiner la sélection de la cible
        if selected_target:
            draw_target_selection(screen, *selected_target)

        # Dessiner les compétences de l'unité active
        draw_skills(screen, game.get_active_unit())

        pygame.display.flip()
        clock.tick(60)

    pygame.quit()
    sys.exit()

if __name__ == "__main__":
    main()
